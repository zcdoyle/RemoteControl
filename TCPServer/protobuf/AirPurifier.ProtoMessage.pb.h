// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AirPurifier.ProtoMessage.proto

#ifndef PROTOBUF_AirPurifier_2eProtoMessage_2eproto__INCLUDED
#define PROTOBUF_AirPurifier_2eProtoMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace AirPurifier {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AirPurifier_2eProtoMessage_2eproto();
void protobuf_AssignDesc_AirPurifier_2eProtoMessage_2eproto();
void protobuf_ShutdownFile_AirPurifier_2eProtoMessage_2eproto();

class ProtoMessage;
class ProtoMessage_Status;
class ProtoMessage_Sensor;
class ProtoMessage_Error;
class MySQLRequest;
class MySQLRequest_DeviceInfo;
class MySQLResponse;
class MySQLResponse_DeviceInfo;

// ===================================================================

class ProtoMessage_Status : public ::google::protobuf::Message {
 public:
  ProtoMessage_Status();
  virtual ~ProtoMessage_Status();

  ProtoMessage_Status(const ProtoMessage_Status& from);

  inline ProtoMessage_Status& operator=(const ProtoMessage_Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoMessage_Status& default_instance();

  void Swap(ProtoMessage_Status* other);

  // implements Message ----------------------------------------------

  ProtoMessage_Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoMessage_Status& from);
  void MergeFrom(const ProtoMessage_Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 open = 1;
  inline bool has_open() const;
  inline void clear_open();
  static const int kOpenFieldNumber = 1;
  inline ::google::protobuf::uint32 open() const;
  inline void set_open(::google::protobuf::uint32 value);

  // optional uint32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // optional uint32 wspd = 3;
  inline bool has_wspd() const;
  inline void clear_wspd();
  static const int kWspdFieldNumber = 3;
  inline ::google::protobuf::uint32 wspd() const;
  inline void set_wspd(::google::protobuf::uint32 value);

  // optional uint32 click = 4;
  inline bool has_click() const;
  inline void clear_click();
  static const int kClickFieldNumber = 4;
  inline ::google::protobuf::uint32 click() const;
  inline void set_click(::google::protobuf::uint32 value);

  // optional uint32 ermd = 5;
  inline bool has_ermd() const;
  inline void clear_ermd();
  static const int kErmdFieldNumber = 5;
  inline ::google::protobuf::uint32 ermd() const;
  inline void set_ermd(::google::protobuf::uint32 value);

  // optional uint32 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional uint32 ver = 7;
  inline bool has_ver() const;
  inline void clear_ver();
  static const int kVerFieldNumber = 7;
  inline ::google::protobuf::uint32 ver() const;
  inline void set_ver(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AirPurifier.ProtoMessage.Status)
 private:
  inline void set_has_open();
  inline void clear_has_open();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_wspd();
  inline void clear_has_wspd();
  inline void set_has_click();
  inline void clear_has_click();
  inline void set_has_ermd();
  inline void clear_has_ermd();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_ver();
  inline void clear_has_ver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 open_;
  ::google::protobuf::uint32 mode_;
  ::google::protobuf::uint32 wspd_;
  ::google::protobuf::uint32 click_;
  ::google::protobuf::uint32 ermd_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 ver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_AssignDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_ShutdownFile_AirPurifier_2eProtoMessage_2eproto();

  void InitAsDefaultInstance();
  static ProtoMessage_Status* default_instance_;
};
// -------------------------------------------------------------------

class ProtoMessage_Sensor : public ::google::protobuf::Message {
 public:
  ProtoMessage_Sensor();
  virtual ~ProtoMessage_Sensor();

  ProtoMessage_Sensor(const ProtoMessage_Sensor& from);

  inline ProtoMessage_Sensor& operator=(const ProtoMessage_Sensor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoMessage_Sensor& default_instance();

  void Swap(ProtoMessage_Sensor* other);

  // implements Message ----------------------------------------------

  ProtoMessage_Sensor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoMessage_Sensor& from);
  void MergeFrom(const ProtoMessage_Sensor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float hcho = 1;
  inline bool has_hcho() const;
  inline void clear_hcho();
  static const int kHchoFieldNumber = 1;
  inline float hcho() const;
  inline void set_hcho(float value);

  // optional float pm2p5 = 2;
  inline bool has_pm2p5() const;
  inline void clear_pm2p5();
  static const int kPm2P5FieldNumber = 2;
  inline float pm2p5() const;
  inline void set_pm2p5(float value);

  // optional float temperature = 3;
  inline bool has_temperature() const;
  inline void clear_temperature();
  static const int kTemperatureFieldNumber = 3;
  inline float temperature() const;
  inline void set_temperature(float value);

  // optional float humidity = 4;
  inline bool has_humidity() const;
  inline void clear_humidity();
  static const int kHumidityFieldNumber = 4;
  inline float humidity() const;
  inline void set_humidity(float value);

  // @@protoc_insertion_point(class_scope:AirPurifier.ProtoMessage.Sensor)
 private:
  inline void set_has_hcho();
  inline void clear_has_hcho();
  inline void set_has_pm2p5();
  inline void clear_has_pm2p5();
  inline void set_has_temperature();
  inline void clear_has_temperature();
  inline void set_has_humidity();
  inline void clear_has_humidity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float hcho_;
  float pm2p5_;
  float temperature_;
  float humidity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_AssignDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_ShutdownFile_AirPurifier_2eProtoMessage_2eproto();

  void InitAsDefaultInstance();
  static ProtoMessage_Sensor* default_instance_;
};
// -------------------------------------------------------------------

class ProtoMessage_Error : public ::google::protobuf::Message {
 public:
  ProtoMessage_Error();
  virtual ~ProtoMessage_Error();

  ProtoMessage_Error(const ProtoMessage_Error& from);

  inline ProtoMessage_Error& operator=(const ProtoMessage_Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoMessage_Error& default_instance();

  void Swap(ProtoMessage_Error* other);

  // implements Message ----------------------------------------------

  ProtoMessage_Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoMessage_Error& from);
  void MergeFrom(const ProtoMessage_Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fsc = 1;
  inline bool has_fsc() const;
  inline void clear_fsc();
  static const int kFscFieldNumber = 1;
  inline ::google::protobuf::uint32 fsc() const;
  inline void set_fsc(::google::protobuf::uint32 value);

  // optional uint32 ibc = 2;
  inline bool has_ibc() const;
  inline void clear_ibc();
  static const int kIbcFieldNumber = 2;
  inline ::google::protobuf::uint32 ibc() const;
  inline void set_ibc(::google::protobuf::uint32 value);

  // optional uint32 ibe = 3;
  inline bool has_ibe() const;
  inline void clear_ibe();
  static const int kIbeFieldNumber = 3;
  inline ::google::protobuf::uint32 ibe() const;
  inline void set_ibe(::google::protobuf::uint32 value);

  // optional uint32 uve = 4;
  inline bool has_uve() const;
  inline void clear_uve();
  static const int kUveFieldNumber = 4;
  inline ::google::protobuf::uint32 uve() const;
  inline void set_uve(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AirPurifier.ProtoMessage.Error)
 private:
  inline void set_has_fsc();
  inline void clear_has_fsc();
  inline void set_has_ibc();
  inline void clear_has_ibc();
  inline void set_has_ibe();
  inline void clear_has_ibe();
  inline void set_has_uve();
  inline void clear_has_uve();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 fsc_;
  ::google::protobuf::uint32 ibc_;
  ::google::protobuf::uint32 ibe_;
  ::google::protobuf::uint32 uve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_AssignDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_ShutdownFile_AirPurifier_2eProtoMessage_2eproto();

  void InitAsDefaultInstance();
  static ProtoMessage_Error* default_instance_;
};
// -------------------------------------------------------------------

class ProtoMessage : public ::google::protobuf::Message {
 public:
  ProtoMessage();
  virtual ~ProtoMessage();

  ProtoMessage(const ProtoMessage& from);

  inline ProtoMessage& operator=(const ProtoMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoMessage& default_instance();

  void Swap(ProtoMessage* other);

  // implements Message ----------------------------------------------

  ProtoMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoMessage& from);
  void MergeFrom(const ProtoMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ProtoMessage_Status Status;
  typedef ProtoMessage_Sensor Sensor;
  typedef ProtoMessage_Error Error;

  // accessors -------------------------------------------------------

  // optional uint32 devID = 1;
  inline bool has_devid() const;
  inline void clear_devid();
  static const int kDevIDFieldNumber = 1;
  inline ::google::protobuf::uint32 devid() const;
  inline void set_devid(::google::protobuf::uint32 value);

  // optional string date = 2;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 2;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // optional string time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional .AirPurifier.ProtoMessage.Status status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline const ::AirPurifier::ProtoMessage_Status& status() const;
  inline ::AirPurifier::ProtoMessage_Status* mutable_status();
  inline ::AirPurifier::ProtoMessage_Status* release_status();
  inline void set_allocated_status(::AirPurifier::ProtoMessage_Status* status);

  // optional .AirPurifier.ProtoMessage.Sensor sensor = 5;
  inline bool has_sensor() const;
  inline void clear_sensor();
  static const int kSensorFieldNumber = 5;
  inline const ::AirPurifier::ProtoMessage_Sensor& sensor() const;
  inline ::AirPurifier::ProtoMessage_Sensor* mutable_sensor();
  inline ::AirPurifier::ProtoMessage_Sensor* release_sensor();
  inline void set_allocated_sensor(::AirPurifier::ProtoMessage_Sensor* sensor);

  // optional .AirPurifier.ProtoMessage.Error error = 6;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 6;
  inline const ::AirPurifier::ProtoMessage_Error& error() const;
  inline ::AirPurifier::ProtoMessage_Error* mutable_error();
  inline ::AirPurifier::ProtoMessage_Error* release_error();
  inline void set_allocated_error(::AirPurifier::ProtoMessage_Error* error);

  // optional uint32 messageType = 7;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 messagetype() const;
  inline void set_messagetype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AirPurifier.ProtoMessage)
 private:
  inline void set_has_devid();
  inline void clear_has_devid();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_sensor();
  inline void clear_has_sensor();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_messagetype();
  inline void clear_has_messagetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* date_;
  ::std::string* time_;
  ::AirPurifier::ProtoMessage_Status* status_;
  ::google::protobuf::uint32 devid_;
  ::google::protobuf::uint32 messagetype_;
  ::AirPurifier::ProtoMessage_Sensor* sensor_;
  ::AirPurifier::ProtoMessage_Error* error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_AssignDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_ShutdownFile_AirPurifier_2eProtoMessage_2eproto();

  void InitAsDefaultInstance();
  static ProtoMessage* default_instance_;
};
// -------------------------------------------------------------------

class MySQLRequest_DeviceInfo : public ::google::protobuf::Message {
 public:
  MySQLRequest_DeviceInfo();
  virtual ~MySQLRequest_DeviceInfo();

  MySQLRequest_DeviceInfo(const MySQLRequest_DeviceInfo& from);

  inline MySQLRequest_DeviceInfo& operator=(const MySQLRequest_DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MySQLRequest_DeviceInfo& default_instance();

  void Swap(MySQLRequest_DeviceInfo* other);

  // implements Message ----------------------------------------------

  MySQLRequest_DeviceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MySQLRequest_DeviceInfo& from);
  void MergeFrom(const MySQLRequest_DeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 deviceId = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint32 value);

  // optional float totalPurifiedAir = 3;
  inline bool has_totalpurifiedair() const;
  inline void clear_totalpurifiedair();
  static const int kTotalPurifiedAirFieldNumber = 3;
  inline float totalpurifiedair() const;
  inline void set_totalpurifiedair(float value);

  // optional float totalWordedTime = 4;
  inline bool has_totalwordedtime() const;
  inline void clear_totalwordedtime();
  static const int kTotalWordedTimeFieldNumber = 4;
  inline float totalwordedtime() const;
  inline void set_totalwordedtime(float value);

  // @@protoc_insertion_point(class_scope:AirPurifier.MySQLRequest.DeviceInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_totalpurifiedair();
  inline void clear_has_totalpurifiedair();
  inline void set_has_totalwordedtime();
  inline void clear_has_totalwordedtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 deviceid_;
  float totalpurifiedair_;
  float totalwordedtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_AssignDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_ShutdownFile_AirPurifier_2eProtoMessage_2eproto();

  void InitAsDefaultInstance();
  static MySQLRequest_DeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MySQLRequest : public ::google::protobuf::Message {
 public:
  MySQLRequest();
  virtual ~MySQLRequest();

  MySQLRequest(const MySQLRequest& from);

  inline MySQLRequest& operator=(const MySQLRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MySQLRequest& default_instance();

  void Swap(MySQLRequest* other);

  // implements Message ----------------------------------------------

  MySQLRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MySQLRequest& from);
  void MergeFrom(const MySQLRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MySQLRequest_DeviceInfo DeviceInfo;

  // accessors -------------------------------------------------------

  // optional .AirPurifier.MySQLRequest.DeviceInfo deviceInfo = 1;
  inline bool has_deviceinfo() const;
  inline void clear_deviceinfo();
  static const int kDeviceInfoFieldNumber = 1;
  inline const ::AirPurifier::MySQLRequest_DeviceInfo& deviceinfo() const;
  inline ::AirPurifier::MySQLRequest_DeviceInfo* mutable_deviceinfo();
  inline ::AirPurifier::MySQLRequest_DeviceInfo* release_deviceinfo();
  inline void set_allocated_deviceinfo(::AirPurifier::MySQLRequest_DeviceInfo* deviceinfo);

  // optional string serverDateTime = 2;
  inline bool has_serverdatetime() const;
  inline void clear_serverdatetime();
  static const int kServerDateTimeFieldNumber = 2;
  inline const ::std::string& serverdatetime() const;
  inline void set_serverdatetime(const ::std::string& value);
  inline void set_serverdatetime(const char* value);
  inline void set_serverdatetime(const char* value, size_t size);
  inline ::std::string* mutable_serverdatetime();
  inline ::std::string* release_serverdatetime();
  inline void set_allocated_serverdatetime(::std::string* serverdatetime);

  // optional uint32 messageCode = 3;
  inline bool has_messagecode() const;
  inline void clear_messagecode();
  static const int kMessageCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 messagecode() const;
  inline void set_messagecode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AirPurifier.MySQLRequest)
 private:
  inline void set_has_deviceinfo();
  inline void clear_has_deviceinfo();
  inline void set_has_serverdatetime();
  inline void clear_has_serverdatetime();
  inline void set_has_messagecode();
  inline void clear_has_messagecode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AirPurifier::MySQLRequest_DeviceInfo* deviceinfo_;
  ::std::string* serverdatetime_;
  ::google::protobuf::uint32 messagecode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_AssignDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_ShutdownFile_AirPurifier_2eProtoMessage_2eproto();

  void InitAsDefaultInstance();
  static MySQLRequest* default_instance_;
};
// -------------------------------------------------------------------

class MySQLResponse_DeviceInfo : public ::google::protobuf::Message {
 public:
  MySQLResponse_DeviceInfo();
  virtual ~MySQLResponse_DeviceInfo();

  MySQLResponse_DeviceInfo(const MySQLResponse_DeviceInfo& from);

  inline MySQLResponse_DeviceInfo& operator=(const MySQLResponse_DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MySQLResponse_DeviceInfo& default_instance();

  void Swap(MySQLResponse_DeviceInfo* other);

  // implements Message ----------------------------------------------

  MySQLResponse_DeviceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MySQLResponse_DeviceInfo& from);
  void MergeFrom(const MySQLResponse_DeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 deviceId = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint32 value);

  // optional float totalPurifiedAir = 3;
  inline bool has_totalpurifiedair() const;
  inline void clear_totalpurifiedair();
  static const int kTotalPurifiedAirFieldNumber = 3;
  inline float totalpurifiedair() const;
  inline void set_totalpurifiedair(float value);

  // optional float totalWordedTime = 4;
  inline bool has_totalwordedtime() const;
  inline void clear_totalwordedtime();
  static const int kTotalWordedTimeFieldNumber = 4;
  inline float totalwordedtime() const;
  inline void set_totalwordedtime(float value);

  // @@protoc_insertion_point(class_scope:AirPurifier.MySQLResponse.DeviceInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_totalpurifiedair();
  inline void clear_has_totalpurifiedair();
  inline void set_has_totalwordedtime();
  inline void clear_has_totalwordedtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 deviceid_;
  float totalpurifiedair_;
  float totalwordedtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_AssignDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_ShutdownFile_AirPurifier_2eProtoMessage_2eproto();

  void InitAsDefaultInstance();
  static MySQLResponse_DeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MySQLResponse : public ::google::protobuf::Message {
 public:
  MySQLResponse();
  virtual ~MySQLResponse();

  MySQLResponse(const MySQLResponse& from);

  inline MySQLResponse& operator=(const MySQLResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MySQLResponse& default_instance();

  void Swap(MySQLResponse* other);

  // implements Message ----------------------------------------------

  MySQLResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MySQLResponse& from);
  void MergeFrom(const MySQLResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MySQLResponse_DeviceInfo DeviceInfo;

  // accessors -------------------------------------------------------

  // optional uint32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional .AirPurifier.MySQLResponse.DeviceInfo deviceInfo = 3;
  inline bool has_deviceinfo() const;
  inline void clear_deviceinfo();
  static const int kDeviceInfoFieldNumber = 3;
  inline const ::AirPurifier::MySQLResponse_DeviceInfo& deviceinfo() const;
  inline ::AirPurifier::MySQLResponse_DeviceInfo* mutable_deviceinfo();
  inline ::AirPurifier::MySQLResponse_DeviceInfo* release_deviceinfo();
  inline void set_allocated_deviceinfo(::AirPurifier::MySQLResponse_DeviceInfo* deviceinfo);

  // @@protoc_insertion_point(class_scope:AirPurifier.MySQLResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_deviceinfo();
  inline void clear_has_deviceinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  ::AirPurifier::MySQLResponse_DeviceInfo* deviceinfo_;
  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_AssignDesc_AirPurifier_2eProtoMessage_2eproto();
  friend void protobuf_ShutdownFile_AirPurifier_2eProtoMessage_2eproto();

  void InitAsDefaultInstance();
  static MySQLResponse* default_instance_;
};
// ===================================================================

class MySQLService_Stub;

class MySQLService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline MySQLService() {};
 public:
  virtual ~MySQLService();

  typedef MySQLService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void updateDevice(::google::protobuf::RpcController* controller,
                       const ::AirPurifier::MySQLRequest* request,
                       ::AirPurifier::MySQLResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void queryDevice(::google::protobuf::RpcController* controller,
                       const ::AirPurifier::MySQLRequest* request,
                       ::AirPurifier::MySQLResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MySQLService);
};

class MySQLService_Stub : public MySQLService {
 public:
  MySQLService_Stub(::google::protobuf::RpcChannel* channel);
  MySQLService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~MySQLService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements MySQLService ------------------------------------------

  void updateDevice(::google::protobuf::RpcController* controller,
                       const ::AirPurifier::MySQLRequest* request,
                       ::AirPurifier::MySQLResponse* response,
                       ::google::protobuf::Closure* done);
  void queryDevice(::google::protobuf::RpcController* controller,
                       const ::AirPurifier::MySQLRequest* request,
                       ::AirPurifier::MySQLResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MySQLService_Stub);
};


// ===================================================================


// ===================================================================

// ProtoMessage_Status

// optional uint32 open = 1;
inline bool ProtoMessage_Status::has_open() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoMessage_Status::set_has_open() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoMessage_Status::clear_has_open() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoMessage_Status::clear_open() {
  open_ = 0u;
  clear_has_open();
}
inline ::google::protobuf::uint32 ProtoMessage_Status::open() const {
  return open_;
}
inline void ProtoMessage_Status::set_open(::google::protobuf::uint32 value) {
  set_has_open();
  open_ = value;
}

// optional uint32 mode = 2;
inline bool ProtoMessage_Status::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoMessage_Status::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoMessage_Status::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoMessage_Status::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 ProtoMessage_Status::mode() const {
  return mode_;
}
inline void ProtoMessage_Status::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
}

// optional uint32 wspd = 3;
inline bool ProtoMessage_Status::has_wspd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoMessage_Status::set_has_wspd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoMessage_Status::clear_has_wspd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoMessage_Status::clear_wspd() {
  wspd_ = 0u;
  clear_has_wspd();
}
inline ::google::protobuf::uint32 ProtoMessage_Status::wspd() const {
  return wspd_;
}
inline void ProtoMessage_Status::set_wspd(::google::protobuf::uint32 value) {
  set_has_wspd();
  wspd_ = value;
}

// optional uint32 click = 4;
inline bool ProtoMessage_Status::has_click() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoMessage_Status::set_has_click() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoMessage_Status::clear_has_click() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoMessage_Status::clear_click() {
  click_ = 0u;
  clear_has_click();
}
inline ::google::protobuf::uint32 ProtoMessage_Status::click() const {
  return click_;
}
inline void ProtoMessage_Status::set_click(::google::protobuf::uint32 value) {
  set_has_click();
  click_ = value;
}

// optional uint32 ermd = 5;
inline bool ProtoMessage_Status::has_ermd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoMessage_Status::set_has_ermd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoMessage_Status::clear_has_ermd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoMessage_Status::clear_ermd() {
  ermd_ = 0u;
  clear_has_ermd();
}
inline ::google::protobuf::uint32 ProtoMessage_Status::ermd() const {
  return ermd_;
}
inline void ProtoMessage_Status::set_ermd(::google::protobuf::uint32 value) {
  set_has_ermd();
  ermd_ = value;
}

// optional uint32 time = 6;
inline bool ProtoMessage_Status::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoMessage_Status::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoMessage_Status::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoMessage_Status::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 ProtoMessage_Status::time() const {
  return time_;
}
inline void ProtoMessage_Status::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional uint32 ver = 7;
inline bool ProtoMessage_Status::has_ver() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoMessage_Status::set_has_ver() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoMessage_Status::clear_has_ver() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoMessage_Status::clear_ver() {
  ver_ = 0u;
  clear_has_ver();
}
inline ::google::protobuf::uint32 ProtoMessage_Status::ver() const {
  return ver_;
}
inline void ProtoMessage_Status::set_ver(::google::protobuf::uint32 value) {
  set_has_ver();
  ver_ = value;
}

// -------------------------------------------------------------------

// ProtoMessage_Sensor

// optional float hcho = 1;
inline bool ProtoMessage_Sensor::has_hcho() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoMessage_Sensor::set_has_hcho() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoMessage_Sensor::clear_has_hcho() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoMessage_Sensor::clear_hcho() {
  hcho_ = 0;
  clear_has_hcho();
}
inline float ProtoMessage_Sensor::hcho() const {
  return hcho_;
}
inline void ProtoMessage_Sensor::set_hcho(float value) {
  set_has_hcho();
  hcho_ = value;
}

// optional float pm2p5 = 2;
inline bool ProtoMessage_Sensor::has_pm2p5() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoMessage_Sensor::set_has_pm2p5() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoMessage_Sensor::clear_has_pm2p5() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoMessage_Sensor::clear_pm2p5() {
  pm2p5_ = 0;
  clear_has_pm2p5();
}
inline float ProtoMessage_Sensor::pm2p5() const {
  return pm2p5_;
}
inline void ProtoMessage_Sensor::set_pm2p5(float value) {
  set_has_pm2p5();
  pm2p5_ = value;
}

// optional float temperature = 3;
inline bool ProtoMessage_Sensor::has_temperature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoMessage_Sensor::set_has_temperature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoMessage_Sensor::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoMessage_Sensor::clear_temperature() {
  temperature_ = 0;
  clear_has_temperature();
}
inline float ProtoMessage_Sensor::temperature() const {
  return temperature_;
}
inline void ProtoMessage_Sensor::set_temperature(float value) {
  set_has_temperature();
  temperature_ = value;
}

// optional float humidity = 4;
inline bool ProtoMessage_Sensor::has_humidity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoMessage_Sensor::set_has_humidity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoMessage_Sensor::clear_has_humidity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoMessage_Sensor::clear_humidity() {
  humidity_ = 0;
  clear_has_humidity();
}
inline float ProtoMessage_Sensor::humidity() const {
  return humidity_;
}
inline void ProtoMessage_Sensor::set_humidity(float value) {
  set_has_humidity();
  humidity_ = value;
}

// -------------------------------------------------------------------

// ProtoMessage_Error

// optional uint32 fsc = 1;
inline bool ProtoMessage_Error::has_fsc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoMessage_Error::set_has_fsc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoMessage_Error::clear_has_fsc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoMessage_Error::clear_fsc() {
  fsc_ = 0u;
  clear_has_fsc();
}
inline ::google::protobuf::uint32 ProtoMessage_Error::fsc() const {
  return fsc_;
}
inline void ProtoMessage_Error::set_fsc(::google::protobuf::uint32 value) {
  set_has_fsc();
  fsc_ = value;
}

// optional uint32 ibc = 2;
inline bool ProtoMessage_Error::has_ibc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoMessage_Error::set_has_ibc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoMessage_Error::clear_has_ibc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoMessage_Error::clear_ibc() {
  ibc_ = 0u;
  clear_has_ibc();
}
inline ::google::protobuf::uint32 ProtoMessage_Error::ibc() const {
  return ibc_;
}
inline void ProtoMessage_Error::set_ibc(::google::protobuf::uint32 value) {
  set_has_ibc();
  ibc_ = value;
}

// optional uint32 ibe = 3;
inline bool ProtoMessage_Error::has_ibe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoMessage_Error::set_has_ibe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoMessage_Error::clear_has_ibe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoMessage_Error::clear_ibe() {
  ibe_ = 0u;
  clear_has_ibe();
}
inline ::google::protobuf::uint32 ProtoMessage_Error::ibe() const {
  return ibe_;
}
inline void ProtoMessage_Error::set_ibe(::google::protobuf::uint32 value) {
  set_has_ibe();
  ibe_ = value;
}

// optional uint32 uve = 4;
inline bool ProtoMessage_Error::has_uve() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoMessage_Error::set_has_uve() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoMessage_Error::clear_has_uve() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoMessage_Error::clear_uve() {
  uve_ = 0u;
  clear_has_uve();
}
inline ::google::protobuf::uint32 ProtoMessage_Error::uve() const {
  return uve_;
}
inline void ProtoMessage_Error::set_uve(::google::protobuf::uint32 value) {
  set_has_uve();
  uve_ = value;
}

// -------------------------------------------------------------------

// ProtoMessage

// optional uint32 devID = 1;
inline bool ProtoMessage::has_devid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoMessage::set_has_devid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoMessage::clear_has_devid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoMessage::clear_devid() {
  devid_ = 0u;
  clear_has_devid();
}
inline ::google::protobuf::uint32 ProtoMessage::devid() const {
  return devid_;
}
inline void ProtoMessage::set_devid(::google::protobuf::uint32 value) {
  set_has_devid();
  devid_ = value;
}

// optional string date = 2;
inline bool ProtoMessage::has_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoMessage::set_has_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoMessage::clear_has_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoMessage::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& ProtoMessage::date() const {
  return *date_;
}
inline void ProtoMessage::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void ProtoMessage::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void ProtoMessage::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoMessage::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* ProtoMessage::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoMessage::set_allocated_date(::std::string* date) {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 3;
inline bool ProtoMessage::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoMessage::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoMessage::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoMessage::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& ProtoMessage::time() const {
  return *time_;
}
inline void ProtoMessage::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void ProtoMessage::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void ProtoMessage::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoMessage::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* ProtoMessage::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoMessage::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .AirPurifier.ProtoMessage.Status status = 4;
inline bool ProtoMessage::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoMessage::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoMessage::clear_status() {
  if (status_ != NULL) status_->::AirPurifier::ProtoMessage_Status::Clear();
  clear_has_status();
}
inline const ::AirPurifier::ProtoMessage_Status& ProtoMessage::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::AirPurifier::ProtoMessage_Status* ProtoMessage::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::AirPurifier::ProtoMessage_Status;
  return status_;
}
inline ::AirPurifier::ProtoMessage_Status* ProtoMessage::release_status() {
  clear_has_status();
  ::AirPurifier::ProtoMessage_Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline void ProtoMessage::set_allocated_status(::AirPurifier::ProtoMessage_Status* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional .AirPurifier.ProtoMessage.Sensor sensor = 5;
inline bool ProtoMessage::has_sensor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoMessage::set_has_sensor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoMessage::clear_has_sensor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoMessage::clear_sensor() {
  if (sensor_ != NULL) sensor_->::AirPurifier::ProtoMessage_Sensor::Clear();
  clear_has_sensor();
}
inline const ::AirPurifier::ProtoMessage_Sensor& ProtoMessage::sensor() const {
  return sensor_ != NULL ? *sensor_ : *default_instance_->sensor_;
}
inline ::AirPurifier::ProtoMessage_Sensor* ProtoMessage::mutable_sensor() {
  set_has_sensor();
  if (sensor_ == NULL) sensor_ = new ::AirPurifier::ProtoMessage_Sensor;
  return sensor_;
}
inline ::AirPurifier::ProtoMessage_Sensor* ProtoMessage::release_sensor() {
  clear_has_sensor();
  ::AirPurifier::ProtoMessage_Sensor* temp = sensor_;
  sensor_ = NULL;
  return temp;
}
inline void ProtoMessage::set_allocated_sensor(::AirPurifier::ProtoMessage_Sensor* sensor) {
  delete sensor_;
  sensor_ = sensor;
  if (sensor) {
    set_has_sensor();
  } else {
    clear_has_sensor();
  }
}

// optional .AirPurifier.ProtoMessage.Error error = 6;
inline bool ProtoMessage::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoMessage::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoMessage::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoMessage::clear_error() {
  if (error_ != NULL) error_->::AirPurifier::ProtoMessage_Error::Clear();
  clear_has_error();
}
inline const ::AirPurifier::ProtoMessage_Error& ProtoMessage::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::AirPurifier::ProtoMessage_Error* ProtoMessage::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::AirPurifier::ProtoMessage_Error;
  return error_;
}
inline ::AirPurifier::ProtoMessage_Error* ProtoMessage::release_error() {
  clear_has_error();
  ::AirPurifier::ProtoMessage_Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void ProtoMessage::set_allocated_error(::AirPurifier::ProtoMessage_Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// optional uint32 messageType = 7;
inline bool ProtoMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoMessage::clear_messagetype() {
  messagetype_ = 0u;
  clear_has_messagetype();
}
inline ::google::protobuf::uint32 ProtoMessage::messagetype() const {
  return messagetype_;
}
inline void ProtoMessage::set_messagetype(::google::protobuf::uint32 value) {
  set_has_messagetype();
  messagetype_ = value;
}

// -------------------------------------------------------------------

// MySQLRequest_DeviceInfo

// optional uint32 id = 1;
inline bool MySQLRequest_DeviceInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MySQLRequest_DeviceInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MySQLRequest_DeviceInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MySQLRequest_DeviceInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MySQLRequest_DeviceInfo::id() const {
  return id_;
}
inline void MySQLRequest_DeviceInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 deviceId = 2;
inline bool MySQLRequest_DeviceInfo::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MySQLRequest_DeviceInfo::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MySQLRequest_DeviceInfo::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MySQLRequest_DeviceInfo::clear_deviceid() {
  deviceid_ = 0u;
  clear_has_deviceid();
}
inline ::google::protobuf::uint32 MySQLRequest_DeviceInfo::deviceid() const {
  return deviceid_;
}
inline void MySQLRequest_DeviceInfo::set_deviceid(::google::protobuf::uint32 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional float totalPurifiedAir = 3;
inline bool MySQLRequest_DeviceInfo::has_totalpurifiedair() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MySQLRequest_DeviceInfo::set_has_totalpurifiedair() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MySQLRequest_DeviceInfo::clear_has_totalpurifiedair() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MySQLRequest_DeviceInfo::clear_totalpurifiedair() {
  totalpurifiedair_ = 0;
  clear_has_totalpurifiedair();
}
inline float MySQLRequest_DeviceInfo::totalpurifiedair() const {
  return totalpurifiedair_;
}
inline void MySQLRequest_DeviceInfo::set_totalpurifiedair(float value) {
  set_has_totalpurifiedair();
  totalpurifiedair_ = value;
}

// optional float totalWordedTime = 4;
inline bool MySQLRequest_DeviceInfo::has_totalwordedtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MySQLRequest_DeviceInfo::set_has_totalwordedtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MySQLRequest_DeviceInfo::clear_has_totalwordedtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MySQLRequest_DeviceInfo::clear_totalwordedtime() {
  totalwordedtime_ = 0;
  clear_has_totalwordedtime();
}
inline float MySQLRequest_DeviceInfo::totalwordedtime() const {
  return totalwordedtime_;
}
inline void MySQLRequest_DeviceInfo::set_totalwordedtime(float value) {
  set_has_totalwordedtime();
  totalwordedtime_ = value;
}

// -------------------------------------------------------------------

// MySQLRequest

// optional .AirPurifier.MySQLRequest.DeviceInfo deviceInfo = 1;
inline bool MySQLRequest::has_deviceinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MySQLRequest::set_has_deviceinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MySQLRequest::clear_has_deviceinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MySQLRequest::clear_deviceinfo() {
  if (deviceinfo_ != NULL) deviceinfo_->::AirPurifier::MySQLRequest_DeviceInfo::Clear();
  clear_has_deviceinfo();
}
inline const ::AirPurifier::MySQLRequest_DeviceInfo& MySQLRequest::deviceinfo() const {
  return deviceinfo_ != NULL ? *deviceinfo_ : *default_instance_->deviceinfo_;
}
inline ::AirPurifier::MySQLRequest_DeviceInfo* MySQLRequest::mutable_deviceinfo() {
  set_has_deviceinfo();
  if (deviceinfo_ == NULL) deviceinfo_ = new ::AirPurifier::MySQLRequest_DeviceInfo;
  return deviceinfo_;
}
inline ::AirPurifier::MySQLRequest_DeviceInfo* MySQLRequest::release_deviceinfo() {
  clear_has_deviceinfo();
  ::AirPurifier::MySQLRequest_DeviceInfo* temp = deviceinfo_;
  deviceinfo_ = NULL;
  return temp;
}
inline void MySQLRequest::set_allocated_deviceinfo(::AirPurifier::MySQLRequest_DeviceInfo* deviceinfo) {
  delete deviceinfo_;
  deviceinfo_ = deviceinfo;
  if (deviceinfo) {
    set_has_deviceinfo();
  } else {
    clear_has_deviceinfo();
  }
}

// optional string serverDateTime = 2;
inline bool MySQLRequest::has_serverdatetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MySQLRequest::set_has_serverdatetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MySQLRequest::clear_has_serverdatetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MySQLRequest::clear_serverdatetime() {
  if (serverdatetime_ != &::google::protobuf::internal::kEmptyString) {
    serverdatetime_->clear();
  }
  clear_has_serverdatetime();
}
inline const ::std::string& MySQLRequest::serverdatetime() const {
  return *serverdatetime_;
}
inline void MySQLRequest::set_serverdatetime(const ::std::string& value) {
  set_has_serverdatetime();
  if (serverdatetime_ == &::google::protobuf::internal::kEmptyString) {
    serverdatetime_ = new ::std::string;
  }
  serverdatetime_->assign(value);
}
inline void MySQLRequest::set_serverdatetime(const char* value) {
  set_has_serverdatetime();
  if (serverdatetime_ == &::google::protobuf::internal::kEmptyString) {
    serverdatetime_ = new ::std::string;
  }
  serverdatetime_->assign(value);
}
inline void MySQLRequest::set_serverdatetime(const char* value, size_t size) {
  set_has_serverdatetime();
  if (serverdatetime_ == &::google::protobuf::internal::kEmptyString) {
    serverdatetime_ = new ::std::string;
  }
  serverdatetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MySQLRequest::mutable_serverdatetime() {
  set_has_serverdatetime();
  if (serverdatetime_ == &::google::protobuf::internal::kEmptyString) {
    serverdatetime_ = new ::std::string;
  }
  return serverdatetime_;
}
inline ::std::string* MySQLRequest::release_serverdatetime() {
  clear_has_serverdatetime();
  if (serverdatetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverdatetime_;
    serverdatetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MySQLRequest::set_allocated_serverdatetime(::std::string* serverdatetime) {
  if (serverdatetime_ != &::google::protobuf::internal::kEmptyString) {
    delete serverdatetime_;
  }
  if (serverdatetime) {
    set_has_serverdatetime();
    serverdatetime_ = serverdatetime;
  } else {
    clear_has_serverdatetime();
    serverdatetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 messageCode = 3;
inline bool MySQLRequest::has_messagecode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MySQLRequest::set_has_messagecode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MySQLRequest::clear_has_messagecode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MySQLRequest::clear_messagecode() {
  messagecode_ = 0u;
  clear_has_messagecode();
}
inline ::google::protobuf::uint32 MySQLRequest::messagecode() const {
  return messagecode_;
}
inline void MySQLRequest::set_messagecode(::google::protobuf::uint32 value) {
  set_has_messagecode();
  messagecode_ = value;
}

// -------------------------------------------------------------------

// MySQLResponse_DeviceInfo

// optional uint32 id = 1;
inline bool MySQLResponse_DeviceInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MySQLResponse_DeviceInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MySQLResponse_DeviceInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MySQLResponse_DeviceInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MySQLResponse_DeviceInfo::id() const {
  return id_;
}
inline void MySQLResponse_DeviceInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 deviceId = 2;
inline bool MySQLResponse_DeviceInfo::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MySQLResponse_DeviceInfo::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MySQLResponse_DeviceInfo::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MySQLResponse_DeviceInfo::clear_deviceid() {
  deviceid_ = 0u;
  clear_has_deviceid();
}
inline ::google::protobuf::uint32 MySQLResponse_DeviceInfo::deviceid() const {
  return deviceid_;
}
inline void MySQLResponse_DeviceInfo::set_deviceid(::google::protobuf::uint32 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional float totalPurifiedAir = 3;
inline bool MySQLResponse_DeviceInfo::has_totalpurifiedair() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MySQLResponse_DeviceInfo::set_has_totalpurifiedair() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MySQLResponse_DeviceInfo::clear_has_totalpurifiedair() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MySQLResponse_DeviceInfo::clear_totalpurifiedair() {
  totalpurifiedair_ = 0;
  clear_has_totalpurifiedair();
}
inline float MySQLResponse_DeviceInfo::totalpurifiedair() const {
  return totalpurifiedair_;
}
inline void MySQLResponse_DeviceInfo::set_totalpurifiedair(float value) {
  set_has_totalpurifiedair();
  totalpurifiedair_ = value;
}

// optional float totalWordedTime = 4;
inline bool MySQLResponse_DeviceInfo::has_totalwordedtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MySQLResponse_DeviceInfo::set_has_totalwordedtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MySQLResponse_DeviceInfo::clear_has_totalwordedtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MySQLResponse_DeviceInfo::clear_totalwordedtime() {
  totalwordedtime_ = 0;
  clear_has_totalwordedtime();
}
inline float MySQLResponse_DeviceInfo::totalwordedtime() const {
  return totalwordedtime_;
}
inline void MySQLResponse_DeviceInfo::set_totalwordedtime(float value) {
  set_has_totalwordedtime();
  totalwordedtime_ = value;
}

// -------------------------------------------------------------------

// MySQLResponse

// optional uint32 status = 1;
inline bool MySQLResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MySQLResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MySQLResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MySQLResponse::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 MySQLResponse::status() const {
  return status_;
}
inline void MySQLResponse::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional string message = 2;
inline bool MySQLResponse::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MySQLResponse::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MySQLResponse::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MySQLResponse::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& MySQLResponse::message() const {
  return *message_;
}
inline void MySQLResponse::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void MySQLResponse::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void MySQLResponse::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MySQLResponse::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* MySQLResponse::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MySQLResponse::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .AirPurifier.MySQLResponse.DeviceInfo deviceInfo = 3;
inline bool MySQLResponse::has_deviceinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MySQLResponse::set_has_deviceinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MySQLResponse::clear_has_deviceinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MySQLResponse::clear_deviceinfo() {
  if (deviceinfo_ != NULL) deviceinfo_->::AirPurifier::MySQLResponse_DeviceInfo::Clear();
  clear_has_deviceinfo();
}
inline const ::AirPurifier::MySQLResponse_DeviceInfo& MySQLResponse::deviceinfo() const {
  return deviceinfo_ != NULL ? *deviceinfo_ : *default_instance_->deviceinfo_;
}
inline ::AirPurifier::MySQLResponse_DeviceInfo* MySQLResponse::mutable_deviceinfo() {
  set_has_deviceinfo();
  if (deviceinfo_ == NULL) deviceinfo_ = new ::AirPurifier::MySQLResponse_DeviceInfo;
  return deviceinfo_;
}
inline ::AirPurifier::MySQLResponse_DeviceInfo* MySQLResponse::release_deviceinfo() {
  clear_has_deviceinfo();
  ::AirPurifier::MySQLResponse_DeviceInfo* temp = deviceinfo_;
  deviceinfo_ = NULL;
  return temp;
}
inline void MySQLResponse::set_allocated_deviceinfo(::AirPurifier::MySQLResponse_DeviceInfo* deviceinfo) {
  delete deviceinfo_;
  deviceinfo_ = deviceinfo;
  if (deviceinfo) {
    set_has_deviceinfo();
  } else {
    clear_has_deviceinfo();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace AirPurifier

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AirPurifier_2eProtoMessage_2eproto__INCLUDED
